// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reservation.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countReservationsByEventID = `-- name: CountReservationsByEventID :one
SELECT COUNT(*) FROM Reservation
WHERE event_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountReservationsByEventID(ctx context.Context, eventID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countReservationsByEventID, eventID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReservationsByUserID = `-- name: CountReservationsByUserID :one
SELECT COUNT(*) FROM Reservation
WHERE user_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountReservationsByUserID(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countReservationsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReservation = `-- name: CreateReservation :one
INSERT INTO Reservation (
    id,
    user_id,
    event_id,
    status,
    total_price,
    stripe_session_id
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, created_at, updated_at, deleted_at, user_id, event_id, status, stripe_session_id, total_price
`

type CreateReservationParams struct {
	ID              pgtype.UUID `json:"id"`
	UserID          pgtype.UUID `json:"user_id"`
	EventID         pgtype.UUID `json:"event_id"`
	Status          string      `json:"status"`
	TotalPrice      float64     `json:"total_price"`
	StripeSessionID string      `json:"stripe_session_id"`
}

func (q *Queries) CreateReservation(ctx context.Context, arg CreateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, createReservation,
		arg.ID,
		arg.UserID,
		arg.EventID,
		arg.Status,
		arg.TotalPrice,
		arg.StripeSessionID,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.EventID,
		&i.Status,
		&i.StripeSessionID,
		&i.TotalPrice,
	)
	return i, err
}

const deleteReservation = `-- name: DeleteReservation :exec
UPDATE Reservation
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteReservation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteReservation, id)
	return err
}

const getReservation = `-- name: GetReservation :one
SELECT id, created_at, updated_at, deleted_at, user_id, event_id, status, stripe_session_id, total_price FROM Reservation
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetReservation(ctx context.Context, id pgtype.UUID) (Reservation, error) {
	row := q.db.QueryRow(ctx, getReservation, id)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.EventID,
		&i.Status,
		&i.StripeSessionID,
		&i.TotalPrice,
	)
	return i, err
}

const getReservationByID = `-- name: GetReservationByID :one
SELECT id, created_at, updated_at, deleted_at, user_id, event_id, status, stripe_session_id, total_price FROM Reservation
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetReservationByID(ctx context.Context, id pgtype.UUID) (Reservation, error) {
	row := q.db.QueryRow(ctx, getReservationByID, id)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.EventID,
		&i.Status,
		&i.StripeSessionID,
		&i.TotalPrice,
	)
	return i, err
}

const getReservationByStripeSessionID = `-- name: GetReservationByStripeSessionID :one
SELECT id, created_at, updated_at, deleted_at, user_id, event_id, status, stripe_session_id, total_price FROM Reservation
WHERE stripe_session_id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetReservationByStripeSessionID(ctx context.Context, stripeSessionID string) (Reservation, error) {
	row := q.db.QueryRow(ctx, getReservationByStripeSessionID, stripeSessionID)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.EventID,
		&i.Status,
		&i.StripeSessionID,
		&i.TotalPrice,
	)
	return i, err
}

const hardDeleteReservation = `-- name: HardDeleteReservation :exec
DELETE FROM Reservation
WHERE id = $1
`

func (q *Queries) HardDeleteReservation(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteReservation, id)
	return err
}

const listReservations = `-- name: ListReservations :many
SELECT id, created_at, updated_at, deleted_at, user_id, event_id, status, stripe_session_id, total_price FROM Reservation
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListReservations(ctx context.Context) ([]Reservation, error) {
	rows, err := q.db.Query(ctx, listReservations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.EventID,
			&i.Status,
			&i.StripeSessionID,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByEventID = `-- name: ListReservationsByEventID :many
SELECT id, created_at, updated_at, deleted_at, user_id, event_id, status, stripe_session_id, total_price FROM Reservation
WHERE event_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListReservationsByEventID(ctx context.Context, eventID pgtype.UUID) ([]Reservation, error) {
	rows, err := q.db.Query(ctx, listReservationsByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.EventID,
			&i.Status,
			&i.StripeSessionID,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByStatus = `-- name: ListReservationsByStatus :many
SELECT id, created_at, updated_at, deleted_at, user_id, event_id, status, stripe_session_id, total_price FROM Reservation
WHERE status = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListReservationsByStatus(ctx context.Context, status string) ([]Reservation, error) {
	rows, err := q.db.Query(ctx, listReservationsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.EventID,
			&i.Status,
			&i.StripeSessionID,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReservationsByUserID = `-- name: ListReservationsByUserID :many
SELECT id, created_at, updated_at, deleted_at, user_id, event_id, status, stripe_session_id, total_price FROM Reservation
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListReservationsByUserID(ctx context.Context, userID pgtype.UUID) ([]Reservation, error) {
	rows, err := q.db.Query(ctx, listReservationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reservation{}
	for rows.Next() {
		var i Reservation
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.EventID,
			&i.Status,
			&i.StripeSessionID,
			&i.TotalPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReservation = `-- name: UpdateReservation :one
UPDATE Reservation
SET
    user_id = COALESCE($1, user_id),
    event_id = COALESCE($2, event_id),
    status = COALESCE($3, status),
    updated_at = NOW()
WHERE id = $4 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, user_id, event_id, status, stripe_session_id, total_price
`

type UpdateReservationParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	EventID pgtype.UUID `json:"event_id"`
	Status  *string     `json:"status"`
	ID      pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateReservation(ctx context.Context, arg UpdateReservationParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, updateReservation,
		arg.UserID,
		arg.EventID,
		arg.Status,
		arg.ID,
	)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.EventID,
		&i.Status,
		&i.StripeSessionID,
		&i.TotalPrice,
	)
	return i, err
}

const updateReservationStatus = `-- name: UpdateReservationStatus :one
UPDATE Reservation
SET status = $2, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, user_id, event_id, status, stripe_session_id, total_price
`

type UpdateReservationStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateReservationStatus(ctx context.Context, arg UpdateReservationStatusParams) (Reservation, error) {
	row := q.db.QueryRow(ctx, updateReservationStatus, arg.ID, arg.Status)
	var i Reservation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.EventID,
		&i.Status,
		&i.StripeSessionID,
		&i.TotalPrice,
	)
	return i, err
}
