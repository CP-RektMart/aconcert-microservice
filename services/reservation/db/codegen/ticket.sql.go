// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ticket.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkSeatAvailability = `-- name: CheckSeatAvailability :one
SELECT EXISTS(
    SELECT 1 FROM Ticket
    WHERE zone_number = $1
        AND row_number = $2
        AND col_number = $3
        AND deleted_at IS NULL
) AS is_taken
`

type CheckSeatAvailabilityParams struct {
	ZoneNumber int32 `json:"zone_number"`
	RowNumber  int32 `json:"row_number"`
	ColNumber  int32 `json:"col_number"`
}

func (q *Queries) CheckSeatAvailability(ctx context.Context, arg CheckSeatAvailabilityParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkSeatAvailability, arg.ZoneNumber, arg.RowNumber, arg.ColNumber)
	var is_taken bool
	err := row.Scan(&is_taken)
	return is_taken, err
}

const checkSeatAvailabilityForEvent = `-- name: CheckSeatAvailabilityForEvent :one
SELECT EXISTS(
    SELECT 1 FROM Ticket
    WHERE event_id = $1
        AND zone_number = $2
        AND row_number = $3
        AND col_number = $4
        AND deleted_at IS NULL
) AS is_taken
`

type CheckSeatAvailabilityForEventParams struct {
	EventID    pgtype.UUID `json:"event_id"`
	ZoneNumber int32       `json:"zone_number"`
	RowNumber  int32       `json:"row_number"`
	ColNumber  int32       `json:"col_number"`
}

func (q *Queries) CheckSeatAvailabilityForEvent(ctx context.Context, arg CheckSeatAvailabilityForEventParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkSeatAvailabilityForEvent,
		arg.EventID,
		arg.ZoneNumber,
		arg.RowNumber,
		arg.ColNumber,
	)
	var is_taken bool
	err := row.Scan(&is_taken)
	return is_taken, err
}

const countTicketsByReservationID = `-- name: CountTicketsByReservationID :one
SELECT COUNT(*) FROM Ticket
WHERE reservation_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountTicketsByReservationID(ctx context.Context, reservationID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countTicketsByReservationID, reservationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTicket = `-- name: CreateTicket :one
INSERT INTO Ticket (
    reservation_id,
    zone_number,
    row_number,
    col_number,
    event_id
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, reservation_id, created_at, updated_at, deleted_at, zone_number, row_number, col_number, event_id
`

type CreateTicketParams struct {
	ReservationID pgtype.UUID `json:"reservation_id"`
	ZoneNumber    int32       `json:"zone_number"`
	RowNumber     int32       `json:"row_number"`
	ColNumber     int32       `json:"col_number"`
	EventID       pgtype.UUID `json:"event_id"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, createTicket,
		arg.ReservationID,
		arg.ZoneNumber,
		arg.RowNumber,
		arg.ColNumber,
		arg.EventID,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ZoneNumber,
		&i.RowNumber,
		&i.ColNumber,
		&i.EventID,
	)
	return i, err
}

const createTicketWithAvailabilityCheck = `-- name: CreateTicketWithAvailabilityCheck :one
WITH seat_check AS (
    SELECT EXISTS(
        SELECT 1 FROM Ticket
        WHERE event_id = $1
            AND zone_number = $2
            AND row_number = $3
            AND col_number = $4
            AND deleted_at IS NULL
    ) AS is_taken
)
INSERT INTO Ticket (
    reservation_id,
    zone_number,
    row_number,
    col_number,
    event_id
)
SELECT $5, $2, $3, $4, $1
FROM seat_check
WHERE NOT is_taken
RETURNING id, reservation_id, created_at, updated_at, deleted_at, zone_number, row_number, col_number, event_id
`

type CreateTicketWithAvailabilityCheckParams struct {
	EventID       pgtype.UUID `json:"event_id"`
	ZoneNumber    int32       `json:"zone_number"`
	RowNumber     int32       `json:"row_number"`
	ColNumber     int32       `json:"col_number"`
	ReservationID pgtype.UUID `json:"reservation_id"`
}

func (q *Queries) CreateTicketWithAvailabilityCheck(ctx context.Context, arg CreateTicketWithAvailabilityCheckParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, createTicketWithAvailabilityCheck,
		arg.EventID,
		arg.ZoneNumber,
		arg.RowNumber,
		arg.ColNumber,
		arg.ReservationID,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ZoneNumber,
		&i.RowNumber,
		&i.ColNumber,
		&i.EventID,
	)
	return i, err
}

const deleteTicket = `-- name: DeleteTicket :exec
UPDATE Ticket
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteTicket(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTicket, id)
	return err
}

const deleteTicketsByReservationID = `-- name: DeleteTicketsByReservationID :exec
UPDATE Ticket
SET deleted_at = NOW(), updated_at = NOW()
WHERE reservation_id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteTicketsByReservationID(ctx context.Context, reservationID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTicketsByReservationID, reservationID)
	return err
}

const getTicket = `-- name: GetTicket :one
SELECT id, reservation_id, created_at, updated_at, deleted_at, zone_number, row_number, col_number, event_id FROM Ticket
WHERE id = $1 AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetTicket(ctx context.Context, id pgtype.UUID) (Ticket, error) {
	row := q.db.QueryRow(ctx, getTicket, id)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ZoneNumber,
		&i.RowNumber,
		&i.ColNumber,
		&i.EventID,
	)
	return i, err
}

const getTicketByID = `-- name: GetTicketByID :one
SELECT id, reservation_id, created_at, updated_at, deleted_at, zone_number, row_number, col_number, event_id FROM Ticket
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetTicketByID(ctx context.Context, id pgtype.UUID) (Ticket, error) {
	row := q.db.QueryRow(ctx, getTicketByID, id)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ZoneNumber,
		&i.RowNumber,
		&i.ColNumber,
		&i.EventID,
	)
	return i, err
}

const getTicketBySeat = `-- name: GetTicketBySeat :one
SELECT id, reservation_id, created_at, updated_at, deleted_at, zone_number, row_number, col_number, event_id FROM Ticket
WHERE zone_number = $1
    AND row_number = $2
    AND col_number = $3
    AND deleted_at IS NULL
LIMIT 1
`

type GetTicketBySeatParams struct {
	ZoneNumber int32 `json:"zone_number"`
	RowNumber  int32 `json:"row_number"`
	ColNumber  int32 `json:"col_number"`
}

func (q *Queries) GetTicketBySeat(ctx context.Context, arg GetTicketBySeatParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, getTicketBySeat, arg.ZoneNumber, arg.RowNumber, arg.ColNumber)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ZoneNumber,
		&i.RowNumber,
		&i.ColNumber,
		&i.EventID,
	)
	return i, err
}

const hardDeleteTicket = `-- name: HardDeleteTicket :exec
DELETE FROM Ticket
WHERE id = $1
`

func (q *Queries) HardDeleteTicket(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteTicket, id)
	return err
}

const listTickets = `-- name: ListTickets :many
SELECT id, reservation_id, created_at, updated_at, deleted_at, zone_number, row_number, col_number, event_id FROM Ticket
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListTickets(ctx context.Context) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, listTickets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.ReservationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ZoneNumber,
			&i.RowNumber,
			&i.ColNumber,
			&i.EventID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketsByReservationID = `-- name: ListTicketsByReservationID :many
SELECT id, reservation_id, created_at, updated_at, deleted_at, zone_number, row_number, col_number, event_id FROM Ticket
WHERE reservation_id = $1 AND deleted_at IS NULL
ORDER BY zone_number, row_number, col_number
`

func (q *Queries) ListTicketsByReservationID(ctx context.Context, reservationID pgtype.UUID) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, listTicketsByReservationID, reservationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.ReservationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ZoneNumber,
			&i.RowNumber,
			&i.ColNumber,
			&i.EventID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketsBySeat = `-- name: ListTicketsBySeat :many
SELECT id, reservation_id, created_at, updated_at, deleted_at, zone_number, row_number, col_number, event_id FROM Ticket
WHERE zone_number = $1
    AND row_number = $2
    AND col_number = $3
    AND deleted_at IS NULL
ORDER BY created_at DESC
`

type ListTicketsBySeatParams struct {
	ZoneNumber int32 `json:"zone_number"`
	RowNumber  int32 `json:"row_number"`
	ColNumber  int32 `json:"col_number"`
}

func (q *Queries) ListTicketsBySeat(ctx context.Context, arg ListTicketsBySeatParams) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, listTicketsBySeat, arg.ZoneNumber, arg.RowNumber, arg.ColNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.ReservationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ZoneNumber,
			&i.RowNumber,
			&i.ColNumber,
			&i.EventID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicket = `-- name: UpdateTicket :one
UPDATE Ticket
SET
    reservation_id = COALESCE($1, reservation_id),
    zone_number = COALESCE($2, zone_number),
    row_number = COALESCE($3, row_number),
    col_number = COALESCE($4, col_number),
    updated_at = NOW()
WHERE id = $5 AND deleted_at IS NULL
RETURNING id, reservation_id, created_at, updated_at, deleted_at, zone_number, row_number, col_number, event_id
`

type UpdateTicketParams struct {
	ReservationID pgtype.UUID `json:"reservation_id"`
	ZoneNumber    *int32      `json:"zone_number"`
	RowNumber     *int32      `json:"row_number"`
	ColNumber     *int32      `json:"col_number"`
	ID            pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, updateTicket,
		arg.ReservationID,
		arg.ZoneNumber,
		arg.RowNumber,
		arg.ColNumber,
		arg.ID,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ZoneNumber,
		&i.RowNumber,
		&i.ColNumber,
		&i.EventID,
	)
	return i, err
}

const updateTicketReservation = `-- name: UpdateTicketReservation :one
UPDATE Ticket
SET reservation_id = $2, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, reservation_id, created_at, updated_at, deleted_at, zone_number, row_number, col_number, event_id
`

type UpdateTicketReservationParams struct {
	ID            pgtype.UUID `json:"id"`
	ReservationID pgtype.UUID `json:"reservation_id"`
}

func (q *Queries) UpdateTicketReservation(ctx context.Context, arg UpdateTicketReservationParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, updateTicketReservation, arg.ID, arg.ReservationID)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.ReservationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ZoneNumber,
		&i.RowNumber,
		&i.ColNumber,
		&i.EventID,
	)
	return i, err
}
